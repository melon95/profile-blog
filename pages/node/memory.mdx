---
title: 内存管理
keyword: nodejs 内存管理 没存泄漏
---

# 内存管理

由于 V8 引擎的限制，`Node` 不能使用机器的所有内存，在 32 位系统中最大只有约 0.7G，在 64 位系统中最大只有 约 1.4G。这对于浏览器中的短生命周期的页面来说是足够的，但是在长时间运行的 `Node` 服务中还是需要尤为注意的。

> 可以通过启动参数 max-old-space-size 和 max-new-space-size 来重新设置这个大小。

## 内存回收

V8 把内存分为两种类型：存活周期长的（老生代）、存活周期短的（新生代）。新生代如果经过多次内存回收依然还在就会被移入老生代中，因此老生代所占的内存药远远大于新生代，所以 V8 对于新生代和老生代采用的内存回收算法也是不一样的。

### 新生代

新生代内存通过 **Scavenge** 算法进行垃圾回收，通过把内存一分为二：From、To，From 处于使用状态，To 处于闲置状态。定义对象时在 From 中分配内存，垃圾回收时，将 From 中的**存活对象复制**到 To 中，非存活对象将被释放，再交换 From 和 To 空间的用途。

这个算法时典型的空间换时间，因此只适用于新生代内存，因为新生代内存中对象的生命周期比较短。

### 老生代

老生代内存通过 **标记-清除-整理** 进行垃圾回收：

1. 首先标记存活的对象
2. 释放没有被标记的对象
3. 整理内存碎片，避免内存空间出现碎片

> 开头说的内存限制是说的老生代内存，新生代内存在 32 位系统中最大约 16M，64 位系统中最大约 32M

## 内存指标

关于 `Node` 应用的当前的内存信息，可以通过 `process` 对象来查看：

```javascript
process.memoryUsage()
{
  rss: 28999680, // Resident Set Size 常驻内存
  heapTotal: 5029888, // 总堆内存
  heapUsed: 4152560, // 已经使用的堆内存
  external: 320673, // 额外内存
  arrayBuffers: 11218 // 分配给 ArrayBuffer 和 SharedArrayBuffer 的内存
}
```

## 内存泄漏

`Node` 对内存泄漏十分敏感，一旦线上应用有成千上万的流量，哪怕是一个字节的内存泄漏也会堆积，直到内存溢出，应用崩溃。

通常，造成内存泄漏的原因有如下几个：

1. 把内存当缓存
2. 队列消费不及时
3. 作用域未释放
